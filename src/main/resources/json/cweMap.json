{
    "cwe-22": {
        "system_prompt": "In the context of CWE-22, known as \"Path Traversal,\" the source \ntypically refers to the input or data that an attacker can manipulate, such as a function \ndefinition for receiving external input or an assign statement which passes external data. \nThe barrier would be mechanisms designed to prevent the application from accessing unauthorized \nor potentially dangerous locations in the file system. The sink is the vulnerable part of the \napplication, such as a script or function call, which takes this untrusted input and uses \nit to access arbitrary locations on the file system without proper validation, thereby allowing \nthe attacker to navigate the victim towards sensitive or harmful files or directories. \n\nREMEMBER, if a function definition includes parameters named request, url, path, or similar, \nit is considered a source. If a function is related to file operation, its return statement is \nlikely to be a sink. If a function call is associated with file operation such as open or extract, \nit is also likely to be a sink.\n",
        "title": "Path Traversal",
        "description": "CWE-22, also known as \"Path Traversal\" or \"Directory Traversal,\" is \na common vulnerability that occurs when an application allows an attacker to access files or \ndirectories outside the intended directory structure. This vulnerability can be exploited to \nread, modify, or execute arbitrary files on the server, potentially leading to data breaches, \nunauthorized access, or even remote code execution.\n\nThe issue arises when the application fails to properly validate or sanitize user-supplied input \nthat specifies file paths. Attackers can manipulate this input to traverse the directory structure \nand access sensitive files such as configuration files, database files, or system files.",
        "example": "\nConsider the following csv input:\n\nFile_name,Function_name,Line_number_range,Function_contents\nexample1.py,user_picture,(1, 11),1:@app.route(\"/user_picture\")\n2:def user_picture(request):\n3:    base_path = '/server/static/images'\n4:    # filename = request.args.get('p')\n5:    filename = request.base_url\n6:    #GOOD -- Verify with normalised version of path\n7:    fullpath = os.path.normpath(os.path.join(base_path, filename))\n8:    if not fullpath.startswith(base_path):\n9:        raise Exception(\"not allowed\")\n10:    data = open(fullpath, 'rb').read()\n11:    return data\nexample2.py,copy_user_file,(1, 6),1:def copy_user_file(src_path, dest_path):\n2:    try:\n3:        shutil.copyfile(src_path, dest_path)\n4:        print(\"File copied successfully.\")\n5:    except Exception as e:\n6:        print(f\"Error: {e}\")\n\nOutput Json:\n```json\n[\n    {\n        \"file\": \"example1.py\",\n        \"function_name\": \"user_picture\",\n        \"line_number_range\": (1, 11),\n        \"line_number\": 5,\n        \"line_content\": \"filename = request.base_url\"\n        \"type\": \"source\"\n    },\n    {\n        \"file\": \"example1.py\",\n        \"function_name\": \"user_picture\",\n        \"line_number_range\": (1, 11),\n        \"line_number\": 8,\n        \"line_content\": \"if not fullpath.startswith(base_path):\"\n        \"type\": \"barrier\"\n    },\n    {\n        \"file\": \"example1.py\",\n        \"function_name\": \"user_picture\",\n        \"line_number_range\": (1, 11),\n        \"line_number\": 10,\n        \"line_content\": \"data = open(fullpath, 'rb').read()\"\n        \"type\": \"sink\"\n    },\n        \"file\": \"example2.py\",\n        \"function_name\": \"copy_user_file\",\n        \"line_number_range\": (1, 6),\n        \"line_number\": 1,\n        \"line_content\": \"def copy_user_file(src_path, dest_path):\"\n        \"type\": \"source\"\n    },\n        \"file\": \"example2.py\",\n        \"function_name\": \"copy_user_file\",\n        \"line_number_range\": (1, 6),\n        \"line_number\": 3,\n        \"line_content\": \"shutil.copyfile(src_path, dest_path)\"\n        \"type\": \"sink\"\n    }\n]\n```\n\nExplanation:\nexample1.py: In the provided code, the line `filename = request.base_url` is the source because \nit takes user-supplied input directly. The line `if not fullpath.startswith(base_path):` acts as \nthe barrier, ensuring the file path stays within the safe directory. The line \n`data = open(fullpath, 'rb').read()` is the sink, where the untrusted input is used to read the file. \n\nexample2.py: \nIn the provided code, the first line `def copy_user_file(src_path, dest_path):` is the source because \nit defines the function that takes user-supplied inputs src_path and dest_path, which can be manipulated \nby an attacker. The third line `shutil.copyfile(src_path, dest_path)` is the sink, where these untrusted \ninputs are directly used to copy files. \n\n        "
    },
    "cwe-78": {
        "system_prompt": "In the context of CWE-78, known as \"OS Command Injection,\" the source \ntypically refers to the input or data that an attacker can manipulate, such as a function definition \nfor receiving external input where they inject malicious commands. The barrier would be mechanisms \ndesigned to sanitize or validate user inputs to prevent the execution of unauthorized or potentially \nharmful system commands. On the other hand, the sink is the vulnerable part of the application, such \nas a script or function call, which takes this untrusted input and uses it to construct and execute \nsystem commands without proper validation, thereby allowing the attacker to execute arbitrary commands \non the underlying operating system. This interplay between the source and the sink in the absence of \nadequate security measures forms the basis of the OS command injection vulnerability.",
        "title": "OS Command Injection",
        "description": "CWE-78, also known as \"OS Command Injection\", is a common vulnerability \nthat occurs when an application allows an attacker to inject and execute arbitrary commands on the \nunderlying operating system. This vulnerability can be exploited to perform unauthorized actions, \nmanipulate the server, or gain unauthorized access to sensitive data, potentially leading to full \nsystem compromise.\n\nThe issue arises when the application fails to properly validate or sanitize user-supplied input that \nis used to construct system commands. Attackers can manipulate this input to inject additional commands, \nwhich are then executed by the application. For example, if an application uses user input to dynamically \nbuild a command string for execution, an attacker could append malicious commands to the input, causing \nthe application to execute them alongside the intended command.\n\nIn many cases, applications use user inputs to provide functionality like executing system diagnostics, \nmanaging files, or performing administrative tasks. However, if the application does not adequately \nvalidate or sanitize the input before using it in system commands, an attacker can exploit this weakness \nto execute arbitrary commands on the server. ",
        "example": "\nConsider the following csv input:\n\nFile_name,Function_name,Line_number_range,Function_contents\nexample1.py,command_execution_unsafe,(1, 4),1:def command_execution_unsafe(env_name, script_path):\n2:    python_path = Path(sys.executable).parent.parent/\"miniconda3\"/\"envs\"/env_name/\"python\"\n3:    process = subprocess.Popen(f'{python_path} {script_path}', shell=True)\n4:    return process\n\n\nOutput Json:\n```json\n[\n    {\n        \"file\": \"example1.py\",\n        \"function_name\": \"command_execution_unsafe\",\n        \"line_number_range\": (1, 4),\n        \"line_number\": 1,\n        \"line_content\": \"def command_execution_unsafe(env_name, script_path):\"\n        \"type\": \"source\"\n    },\n    {\n        \"file\": \"example1.py\",\n        \"function_name\": \"command_execution_unsafe\",\n        \"line_number_range\": (1, 4),\n        \"line_number\": 3,\n        \"line_content\": \"process = subprocess.Popen(f'{python_path} {script_path}', shell=True)\"\n        \"type\": \"sink\"\n    }\n]\n```\n\nExplanation:\nexample.py1: In the provided code, the first line `def command_execution_unsafe(env_name, script_path):` is \nthe source because it defines the function that takes user-supplied inputs env_name and script_path, \nwhich can be manipulated by an attacker. The third line \n`process = subprocess.Popen(f'{python_path} {script_path}', shell=True)` is the sink, where these \nuntrusted inputs are used to construct and execute a system command. \n        "
    },
    "cwe-79": {
        "system_prompt": "In the context of CWE-79, known as Cross-Site Scripting (XSS), the source \ntypically refers to the input or data that an attacker can manipulate, such as user inputs in form fields, \nURL parameters, or any other external input vectors. This could include function definitions designed to \nreceive such inputs or statements assigning values from external sources. The barrier involves mechanisms \nlike input validation and output encoding designed to prevent untrusted data from being executed as code \nin the user\u2019s browser. The sink is the vulnerable part of the application where the untrusted data is output \nwithout proper sanitization or encoding, leading to execution of malicious scripts by the client's browser. \n\nREMEMBER, if a function definition includes parameters named request, context, url, or similar, it may be \nconsidered a source. If a line of code involves function calls such as dump, mark_safe, render, write, or it \ninserts variables into a string, then it is likely to be a sink.\n",
        "title": "Cross-Site Scripting (XSS)",
        "description": "\nCWE-79, known as \"Cross-Site Scripting\" or \"XSS,\" is a prevalent vulnerability that occurs when an \napplication takes untrusted data and sends it to a web browser without proper validation or escaping. \nThis allows attackers to execute malicious scripts in the context of another user's session. XSS attacks \ncan be used for a variety of purposes, including stealing session cookies, spreading malware, or redirecting \nusers to malicious sites. The core issue stems from the application's failure to ensure that all user-supplied \ninputs are properly sanitized or encoded before being included in the output rendered by the web browser. ",
        "example": "\nConsider the following csv input:\n\nFile_name,Function_name,Line_number_range,Function_contents\n@expose(\"/v1/form_data/\", methods=[\"GET\"])\nexample1.py,query_form_data,(1, 9),1:def query_form_data(self) -> FlaskResponse:  # pylint: disable=no-self-use\n2:    form_data = {}\n3:    slice_id = request.args.get(\"slice_id\")\n4:    if slice_id:\n5:        slc = db.session.query(Slice).filter_by(id=slice_id).one_or_none()\n6:        if slc:\n7:            form_data = slc.form_data.copy()\n8:    update_time_range(form_data)\n9:    return json.dumps(form_data)\nexample2.py,index,(20, 30),20:def index():\n21:    html = \"\"\n22:    app.logger.info(\"Showing HTML page >>> 'homepage'\")\n23:    try:\n24:        app.logger.info(\"Converting to HTML with pandoc >>> 'homepage' ...\")\n25:        html = pypandoc.convert_file(\n26:            os.path.join(cfg.wiki_directory, cfg.homepage), \"html5\", format='md', extra_args=[\"--mathjax\"],\n27:            filters=['pandoc-xnos'])\n28:    except Exception as e:\n29:        app.logger.error(f\"Conversion to HTML failed >>> {str(e)}\")\n30:    return render_template('index.html', homepage=html, system=SYSTEM_SETTINGS)\nexample3.py,gravatar,(2, 9),2:def gravatar(context, user, size=None):\n3:    url = get_gravatar_url(context['request'], user, size)\n4:    if url:\n5:        return ('<img src=\"%s\" width=\"%s\" height=\"%s\" alt=\"%s\" '\n6:                '     class=\"gravatar\"/>' %\n7:                (url, size, size, user.get_full_name() or user.username))\n8:    else:\n9:        return ''\nexample4.py,get,(10, 21),10:def get(self, arg, word=None):\n11:    try:\n12:        limit = self.get_argument(\"limit\")\n13:        word = self.get_argument(\"word\")\n14:        callback = self.get_argument(\"callback\")\n15:        result = rtxcomplete.fuzzy(word, limit);\n16:        result = callback + \"(\" + json.dumps(result) + \");\"\n17:        self.write(result)\n18:    except:\n19:        print(sys.exc_info()[:])\n20:        traceback.print_tb(sys.exc_info()[-1])\n21:        self.write(\"error\")\nexample5.py,oauth_callback,(61, 64),61:def oauth_callback(self):\n62:    LOG.debug(\"Handling Oauth callback...\")\n63:    if request.args.get(\"error\"):\n64:        return f\"<h1>Error: {request.args.get('error')}</h1>\"\n\nOutput Json:\n```json\n[\n    {\n        \"file\": \"example1.py\",\n        \"function_name\": \"query_form_data\",\n        \"line_number_range\": (1, 9),\n        \"line_number\": 3,\n        \"line_content\": \"slice_id = request.args.get(\"slice_id\")\"\n        \"type\": \"source\"\n    },\n    {\n        \"file\": \"example1.py\",\n        \"function_name\": \"query_form_data\",\n        \"line_number_range\": (1, 9),\n        \"line_number\": 9,\n        \"line_content\": \"return json.dumps(form_data)\"\n        \"type\": \"sink\"\n    },\n    {\n        \"file\": \"example2.py\",\n        \"function_name\": \"index\",\n        \"line_number_range\": (20, 30),\n        \"line_number\": 25,\n        \"line_content\": \"html = pypandoc.convert_file(\"\n        \"type\": \"source\"\n    },\n    {\n        \"file\": \"example2.py\",\n        \"function_name\": \"index\",\n        \"line_number_range\": (20, 30),\n        \"line_number\": 30,\n        \"line_content\": \"return render_template('index.html', homepage=html, system=SYSTEM_SETTINGS)\"\n        \"type\": \"sink\"\n    },\n    {\n        \"file\": \"example3.py\",\n        \"function_name\": \"gravatar\",\n        \"line_number_range\": (2, 9),\n        \"line_number\": 2,\n        \"line_content\": \"def gravatar(context, user, size=None):\"\n        \"type\": \"source\"\n    },\n    {\n        \"file\": \"example3.py\",\n        \"function_name\": \"gravatar\",\n        \"line_number_range\": (2, 9),\n        \"line_number\": 5,\n        \"line_content\": \"return ('<img src=\"%s\" width=\"%s\" height=\"%s\" alt=\"%s\" '\"\n        \"type\": \"sink\"\n    },\n    {\n        \"file\": \"example4.py\",\n        \"function_name\": \"get\",\n        \"line_number_range\": (10, 21),\n        \"line_number\": 14,\n        \"line_content\": \"callback = self.get_argument(\"callback\")\"\n        \"type\": \"source\"\n    },\n    {\n        \"file\": \"example4.py\",\n        \"function_name\": \"get\",\n        \"line_number_range\": (10, 21),\n        \"line_number\": 17,\n        \"line_content\": \"self.write(result)\"\n        \"type\": \"sink\"\n    },\n    {\n        \"file\": \"example5.py\",\n        \"function_name\": \"oauth_callback\",\n        \"line_number_range\": (61, 64),\n        \"line_number\": 64,\n        \"line_content\": \"return f\"<h1>Error: {request.args.get('error')}</h1>\"\"\n        \"type\": \"source\"\n    },\n    {\n        \"file\": \"example5.py\",\n        \"function_name\": \"oauth_callback\",\n        \"line_number_range\": (61, 64),\n        \"line_number\": 64,\n        \"line_content\": \"return f\"<h1>Error: {request.args.get('error')}</h1>\"\"\n        \"type\": \"sink\"\n    }\n]\n```\nExplanation:\nexample1.py: In the provided code snippet, the third line is considered a source for CWE-79 because \nit directly retrieves untrusted input from the user through `request.args.get(\"slice_id\")`. The ninth \nline is identified as a sink because it involves sending potentially untrusted data back to the user's \nbrowser without proper encoding or sanitization via `json.dumps(form_data)`.\n\nexample2.py: In the provided code snippet, the line `html = pypandoc.convert_file(` is considered a \nsource because it involves converting an external markdown file into HTML using `pypandoc.convert_file` \nwithout validating or sanitizing the content of the file. The line `return render_template('index.html', \nhomepage=html, system=SYSTEM_SETTINGS)` is identified as a sink because it directly incorporates the \nuntrusted HTML content (`homepage=html`) into the web page through `render_template`.\n\nexample3.py: In the provided code snippet, the line `def gravatar(context, user, size=None):` is considered a \nsource because it retrieves untrusted context from outside input. The line `return ('<img src=\"%s\" width=\"%s\" \nheight=\"%s\" alt=\"%s\" '` is identified as a sink because it inserts variables into a string.\n\nexample4.py: In the given code snippet, line 14 is considered a source because it retrieves untrusted input \ndirectly from the user via `self.get_argument(\"callback\")`. This method of getting arguments can introduce external \ndata into the application, which could potentially be malicious. On the other hand, line 17 is identified as a \nsink because it involves executing or outputting data that could include the untrusted input. Specifically, \n`self.write(result)` writes out the constructed string that incorporates the previously obtained callback function \nname, possibly leading to Cross-Site Scripting (XSS) vulnerabilities if the callback parameter contains malicious \nscript code. \n\nexample5.py: \nIn the provided code snippet, line 64 is considered both a source and a sink due to its handling of untrusted \ninput directly from the request arguments. It acts as a source because it retrieves potentially unsafe data from \n`request.args.get('error')`, which can include input from an external user or system. Simultaneously, it serves as \na sink because this untrusted data is immediately used in an HTML response without any form of sanitization or \nvalidation. Specifically, the error message is embedded directly into the HTML content, which could lead to \nCross-Site Scripting (XSS) vulnerabilities if the 'error' parameter contains malicious script code. \n\n"
    },
    "cwe-601": {
        "system_prompt": "In the context of CWE-601, \nwhich is known as URL Redirection to Untrusted Site ('Open Redirect'), the source \ntypically refers to the input or data that an attacker can control, such as a a function \ndefinition for receiving external input or an assign statement which passes external data. The \nbarrier would be a mechanism designed to stop the application from redirecting users to untrusted \nor malicious websites. The sink is the vulnerable part of the application, such as a return \nstatement or function call, which takes untrusted input and uses it to redirect the user's \nbrowser to a new location without proper validation, thus allowing the attacker to steer the \nvictim towards a potentially harmful site. \n\nREMEMBER, if a function definition includes parameters named request, url, path, or similar, \nit is considered a source. If a function is related to redirection, its return statement is \nlikely to be a sink. If a function call is associated with redirect, it is also likely to be a sink.\n",
        "title": "URL Redirection to Untrusted Site ('Open Redirect')",
        "description": "\nCWE-601, also known as \"URL Redirection to Untrusted Site\" or \"Open Redirect,\" is a common vulnerability that occurs when \nan application allows an attacker to redirect a user to an arbitrary external URL. This vulnerability can be exploited to facilitate \nphishing attacks, distribute malware, or conduct other malicious activities by tricking users into visiting malicious sites. The issue \narises when the application does not properly validate or sanitize the target URL before redirecting the user. ",
        "example": "\nConsider the following csv input:\n\nFile_name,Function_name,Line_number_range,Function_contents\nexample1.py,unsafe_redirect,(7, 15),7: @app.route('/redirect')\n8:def unsafe_redirect():\n9:    next_url = request.args.get('next', '/')\n10:    parsed_url = urlparse(next_url)\n11:    if parsed_url.scheme or parsed_url.netloc:\n12:        print(\"Redirect not allowed to absolute URLs.\")\n13:        abort(400)\n14:    \n15:    return redirect(next_url)\nexample2.py,get,(2, 5),2:def get(request):\n3:    tgpath = request.GET.get(\"path\")\n4:    if tgpath:\n5:        return tgpath\nexample3.py,is_safe_redirect_url,(3, 10),3:def is_safe_redirect_url(url):\n4:    allowed_domains = [\"safe.example.com\"]\n5:    parsed_url = urlparse(url)\n6:    if parsed_url.netloc in allowed_domains:\n7:        return True\n8:    else:\n9:        print(\"Redirect not allowed to this domain.\")\n10:        return False\n\nOutput Json:\n```json\n[\n    {\n        \"file\": \"example1.py\",\n        \"function_name\": \"unsafe_redirect\",\n        \"line_number_range\": (7, 15),\n        \"line_number\": 8,\n        \"line_content\": \"def unsafe_redirect()\"\n        \"type\": \"source\"\n    },\n    {\n        \"file\": \"example1.py\",\n        \"function_name\": \"unsafe_redirect\",\n        \"line_number_range\": (7, 15),\n        \"line_number\": 11,\n        \"line_content\": \"if parsed_url.scheme or parsed_url.netloc:\"\n        \"type\": \"barrier\"\n    },\n    {\n        \"file\": \"example1.py\",\n        \"function_name\": \"unsafe_redirect\",\n        \"line_number_range\": (7, 15),\n        \"line_number\": 15,\n        \"line_content\": \"return redirect(next_url)\"\n        \"type\": \"sink\"\n    },\n    {\n        \"file\": \"example2.py\",\n        \"function_name\": \"get\",\n        \"line_number_range\": (2, 5),\n        \"line_number\": 2,\n        \"line_content\": \"def get(request):\"\n        \"type\": \"source\"\n    },\n    {\n        \"file\": \"example2.py\",\n        \"function_name\": \"get\",\n        \"line_number_range\": (2, 5),\n        \"line_number\": 5,\n        \"line_content\": \"return tgpath\"\n        \"type\": \"sink\"\n    },\n    {\n        \"file\": \"example3.py\",\n        \"function_name\": \"is_safe_redirect_url\",\n        \"line_number_range\": (3, 10),\n        \"line_number\": 3,\n        \"line_content\": \"def is_safe_redirect_url(url):\"\n        \"type\": \"barrier\"\n    }\n]\n```\n\nExplanation:\nexample.py1: In the code snippet, next_url = request.args.get('next', '/') is the source as it retrieves untrusted \ninput from the user. The line if parsed_url.scheme or parsed_url.netloc: acts as the barrier, checking if the URL is \nabsolute and blocking it if so. Finally, return redirect(next_url) is the sink, performing the actual redirection.\n\nexamply2.py: In the context of security analysis, `def get(request):` is considered a source because it's where \nuntrusted input (request) is received, and `return tgpath` is a sink as it returns an unsafe URL to the outside, \nwhich could potentially be invoked by redirect-related functions.\n\nexamply3.py: In the provided code, the is_safe_redirect_url function serves as the barrier, validating \nthis input to ensure it points to a trusted domain. \n        "
    }
}